# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Михайлова С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получила следующие навыки и знания:

 1. Углубила свои познания в теоретической части логического программирования. После написания эссе я смогла посмотреть на логическое программирование с другой стороны, лучше понять, зачем оно необходимо и почему мы его изучаем.
 2. Вспомнила, как писать парсеры на языке Python.
 3. Закрепила навыки, полученные в 3 лабораторной работе, связанные с поиском в пространстве состояний. В КП это было необходимо для построения цепочки родства.
 4. Получила навыки, необходимые в 4 лабораторной работе, связанные в грамматическим разбором предложения.


## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предиката parents(потомок, отец, мать).
 3. Реализовать предикат проверки/поиска: троюродный брат или сестра
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для получения родословного дерева я зарегистрировалась на сервисе MyHeritage.com. Однако ввиду того, что я не хочу указывать свою родословную, то я использовала родословную Льва Толстого. Всего в моем родословном дереве оказалось 31 человек. Это дерево я экспортировала с сайта в формате GEDCOM. 

## Конвертация родословного дерева

Для написания парсера данных из моего GEDCOM файла в необходимый формат на языке Prolog я решила использовать язык программирования Python. Я считаю, что на нём можно написать достаточно лаконичную и понятную программу. Более того, опыт написания парсеров на данном языке у меня уже есть. 
Сама программа работает до невозможного просто. Построчно проходя по файлу, мы находим id человека, его имя и фамилию и добавляем эту информацию в словарь, находим пол человека, информацию о семье (муже и жене), если у них есть дети, и печатаем все в указанном в условии формате.

[Листинг парсера](parser.py)

## Предикат поиска родственника

Согласно варианту мне нужно реализовать предикат поиска троюродных братьев и сестер (triple). Для его реализации я написала еще три предиката -- child (проверяет, являюся ли два человека родителем и ребенком), double (поиск двоюродных братьев и сестер) и sibling (поиск братьев и сестер).

Предикат child проверяет двух людей на родственную связь ребенок-отец.
```prolog
child(Person,Y) :- % "Person" - ребенок у "Y"
    parents(Person, Y, Z);
    parents(Person, Z, Y).
```

Предикат sibling проверяет, есть ли общие родители у двух человек и имеет проверку, не один и тот же ли это человек.
```prolog
subling(Person,Y) :- % Брат или сестра
    parents(Person, U, V),
    parents(Y, U, V),
    Person \= Y.
```
Предикат double проверяет двоюродное родство. Двоюродное родство означает, что родители двух человек являются братьями или сестрами друг друга. Поэтому проверяем родство между всеми родителями данных людей.
```prolog
double(Person,Y) :-
    ((subling(U,V), child(Person,U), child(Y,V));
    (subling(U,V), child(Y,U), child(Person,V))),
    Person \= Y.
```

Предикат triple проверяет троюродное родство, принцип его работы такой же, как и у предиката double, только теперь проверяем родителей на двоюродное родство.
```prolog
triple(Person,Y) :- % Троюродный брат или сестра
    ((double(U,V), child(Person,U), child(Y,V));
    (double(U,V), child(Y,U), child(Person,V))),
    Person \= Y.
```

Результат работы:
```prolog
?- triple(X, 'Lev Tolstoy').
X = 'Elizabeth Tolstaya' .
```

## Определение степени родства

Используем поиск в ширину для того, чтобы найти кратчайшее отношение родства. Реализуем предикаты check_link, для определения прямых отношений между двумя людьми. Прямые - то есть люди связаны на прямую, а не через какого-то человека. В итоге есть проверка отношений муж, жена, брат или сестра, отец, мать, ребенок, родитель. Я не использовала правила для получения дальнего родства, чтобы при поиске цепочек связи между людьми, она не "перескакивала" через родственников, которые связаны на прямую. Далее находится цепочка родственников, по которой и связаны эти люди, затем эту цепочку переводим в цепочку родства и получается ответ.

Результат работы:
```prolog
?- relative('Lev Tolstoy', 'Varvara Odoevskaya', X).
X = [child, child, child].

?- relative_thread('Lev Tolstoy', 'Varvara Odoevskaya', X).
X = ['Lev Tolstoy', 'Maria Volkonskaya', 'Ekaterina Trubetskaya', 'Varvara Odoevskaya'].

?- check_link(subling, 'Kirill Trubetskoy', X).
X = 'Dmitriy Trubetskoy' .
```

## Естественно-языковый интерфейс

Обрабатываем запросы, выполненые на естественном языке и на основе запроса проверяем истинность высказывания или находим родственников. Запоминается последнее имя, на которое производился запрос, с помощью предиката nb_getval. Сначала проверяем корректность построения вопроса. Затем, в зависимости от постановки вопроса, ищем ответ. При анализе предложения также проверяем корректность построения и разбираем его по частям, оборачивая части вопроса в соответсвущие структуры.

Приведу пример одного из правил для предиката ask_question, все остальные построены аналогичным образом. Это правило находит ответ на вопрос, сколько определенных родственников имеет какой-то человек. Сначала мы проверяем корректность входных данных с помощью предикатов question_word, quantity, purals, help_word, have_has, question_mark. Также запоминаем, относительно имени какого человека задается вопрос, с помощью встроенного предиката nb_setval. Это потребуется в дальнейшем для обработки запросов с местоимениями. Приводим множественное число к единственному в предикате pural. ask_relative ищет всех запрашиваемых родственников заданного человека, а setof создает список из найденных уникальных имен. Далее получаем длину этого списка и печатаем результат в нужном порядке.

```prolog
ask_question(List):-
    List = [A,B,C,D,E,F,H],
    question_word(A),
    quantity(B),
    purals(C),
    help_word(D),
    nb_setval(lastName,E),
    have_has(F),
    question_mark(H),

    pural(C1,C),
    setof(X,ask_relative(X,E,C1),T),
    length(T,Res),!,
    write(E),
    write(" has "),
    ((Res =:= 1,write(Res),write(" "),write( C1));(\+(Res =:= 1),write(Res),write(" "),write( C))),!.
```

Результат работы 
```prolog
?- ask_question([how,many,sublings,does,'Ilya Tolstoy',have,?]).
Ilya Tolstoy has 3 sublings
true.

?- ask_question([is, 'Nikolai Tolstoy', his, child,?]).
true.
?- ask_question([who,is,'Nikolai Tolstoy',"'s",child,?]).
Lev Tolstoy is Nikolai Tolstoy's child
true .

?- ask_question([who, is, his, wife, ?]).
Maria Volkonskaya is Nikolai Tolstoy's wife
true.

?- ask_question([is, 'Maria Chaadaeva', 'Sergey Volkonsky', "'s", wife, ?]).
true.

?- ask_question([is,'Nikolai Volkonsky', her, child, ?]).
true.

?- analysis([who,is,'Nikolai Tolstoy',"'s",child,?],X).
X = sentence(question_type(questionWord(who), auxiliaryVerb(is)), names(person('Nikolai Tolstoy', "'s")), relationship_(child), questionMark(?)) .

?- analysis([how,many,sublings,does,'Ilya Tolstoy',have,?],X).
X = sentence(question_type(questionWord(how), much_many(many)), relationship_(sublings), helpWord(does), names(person('Ilya Tolstoy')), haveHas(have), questionMark(?)) .

?- analysis([is, 'Maria Chaadaeva', 'Sergey Volkonsky', "'s", wife, ?], X).
X = sentence(question_type(auxiliaryVerb(is)), names(person('Maria Chaadaeva'), relative_('Sergey Volkonsky', "'s")), relationship_(wife), questionMark(?)) .
```

[Листинг программы](famTolstoy.pl)


## Выводы

Как было отмечено в начале отчёта, мной были получены не только навыки работы на языке Prolog. Помимо прочего, я узнала, как строятся генеалогические деревья, как хранятся в файле и как обрабатываются. Более того, приходилось прибегать к посторонним языкам программирования, в моём случае этим языком был Питон. Также стоит отмеить, что в процессе написания эссе я смогла поближе познакомиться с Прологом, лучше узнать историю его создания и развития, его особенности, понять его место среди других языков программирования. Так, я узнала, что логичесок ерпограммирование не основано на машине фон Неймана, на основе которой создаются практические все современнные компьютеры. Так же я узнала, что основной особенностью логическоего программирования является то, что мы не объясняем компьютеру, как и что делать. Мы даем лишь некоторый набор информации и на основе этого компьютер сам должен решить, что с этой информацией делать.

Данный курс дался мне непросто. К сожалению, по логическому программированию не так много информации, как, скажем, по объектно-ориентированному. Так же данная парадигма сильно отличается от тех, к  которым мы привыкли, а, как известно, переучиваться всегда очень сложно. С другой стороны, мы рассмотрели реальную задачу, с решением которой вряд ли можно справиться лучше, если не прибегать к логическому программированию. Таким образом, мы получили новый опыт и новый впечатления, узнали о кардинально иных идеях, нежели тех, о которых мы слышали до этого.
