# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Михайлова С. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     3         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список - это абстрактный тип данных используемый для хранения упорядоченного набора элементов. Списки языка Prolog являются односвязными, т.е. каждый узел содержит лишь одну ссылку.<br>

В языке Prolog программист не сталкивается с явной работой с указателями в узлах, однако ему нужно иметь общее представление о списках, т.к. являясь основной структурой данных в функциональных и логических языках, они обладают рядом существенных отличий от массивов, используемых в императивных языках (таких как С++, Java, Pascal). В частности, элемент данных может быть очень быстро добавлен или удален из начала односвязного списка. Однако операция произвольного доступа (обращения к n-ному элементу) в списках выполняется гораздо дольше чем в массивах, т.к. требует n операций перехода по ссылкам.<br>

При работе с односвязными списками необходимо выделять первый узел (называемый головой списка), остальные узлы (составляющие хвост списка) можно получить передвигаясь по указателям вплоть до последнего узла. Хвост списка является таким же списком, как и исходный, поэтому обрабатывается аналогичным образом (рекурсивно).<br>

## Задание 1.1: Предикат обработки списка

`change(L1, X, Y, L2).` - замена всех элементов списка с указанным значением на другое значение

Примеры использования:
```prolog
?- change([1,2,3,4,3,2,1], 3, 5, L).
L = [1,2,5,4,5,2,1]
?- change([1, 2, 3,4,3], N, 5, [1,2,5,4,5]).
N = 3
```

Реализация:
```prolog
change([], X, Y, []):-!.
change([X|T], X, Y, [Y|RT]):-change(T, X, Y, RT).
change([H|T], X, Y, [H|RT]):-change(T, X, Y, RT).
```

В данном задании мы последовательно обрабатываем элементы списка, если обрабатываемый элемент равен X, то мы заменяем его на Y, в противном случае уидем дальше.
Реализация через стандартные предикаты?
## Задание 1.2: Предикат обработки числового списка

`split(L, R, T)` - разделение изначального списка на левый и правый.
???
## Задание 2: Реляционное представление данных

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Преимущества представления в three.pl:

* получение оценок студента за экзамен
* легко узнать номер группы студента

Недостатки представления в one.pl:

* по сравнению с four.pl, для пользователя неудобно то, что нельзя по номеру группы получить список группы, а для предмета - оценки.

Предикаты реализованные для работы с three.pl:
* sum_grades(L, C) - сумма оценок.
* average_mark(S,Mark) - срдняя оценка студента
* remove_same(L,L1) - удаление повторяющихся значений
* group_list(L) - список групп
* get_stud(G, L) - список студентов группы
* all_studs(L) - список всех студентов
* stud_not_passed(S, Sub) - проверка, сдал ли студент экзамен
* list_of_not_passed(Sub, L) - список несдавших экзамен
* not_passed(L) - проверка, сдал ли студент все экзамены
* count_do_not_passed(L, C) - количество несдавших экзамен из списка
* group_count(G, C) - количество несдавших экзамен из группы

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

В лабораторной работе прошло знакомство с языком Prolog и компилятором GNU Prolog. Были написаны предикаты обработки списков и числовых списков со стандартными и без стандартных предикатов. Так же были реализованы запросы к реляционному представлению данных.<br>

Prolog является декларативным языком программирования, это был первый подобный опыт, т.к. приходится работать только с императивными языками(С, С++, Python). Интересно то, что в Prolog нет циклов и всё реализуется через обычную рекурсию.<br>

При программировании на Prolog усилия программиста должны быть направлены на описание логической модели фрагмента предметной области решаемой задачи в терминах объектов предметной области, их свойств и отношений между собой, а не деталей программной реализации. Фактически Prolog представляет собой не столько язык для программирования, сколько язык для описания данных и логики их обработки.<br>

Основные области применения Prolog:

* быстрая разработка прототипов прикладных программ;
* автоматический перевод с одного языка на другой;
* создание естественно-языковых интерфейсов для существующих систем;
* символьные вычисления для решения уравнений, дифференцирования и интегрирования;
* проектирование динамических реляционных баз данных;
* экспертные системы и оболочки экспертных систем;
* автоматизированное управление производственными процессами;
* автоматическое доказательство теорем;
* полуавтоматическое составление расписаний;
* системы автоматизированного проектирования, базирующееся на знаниях программное обеспечение;
* организация сервера данных или, точнее, сервера знаний, к которому может обращаться клиентское приложение, написанное на каком-либо языке программирования.<br>

Недостатком языка является его непопулярность. По индексу TIOBE, Prolog занимает  лишь 30 место. Более того, я счиатаю, что обработка данных с помощью привычных нам языков более простая и удобная.<br>
