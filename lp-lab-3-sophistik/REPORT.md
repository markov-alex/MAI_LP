# № Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Михайлова С. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 
Почему Prolog оказывается удобным языком для решения таких задач?

Пространство состояний возникает при разбиении решения задачи на отдельные шаги. Здесь выделяется начальное состояние, когда мы еще не выбрали гипотезу, а также конечное состояние, когда мы нашли гипотезу, которая является допустимым решением нашей задачи. В процессе поиска этой гипотезы есть операции перехода в следующее состояние. Такими методами достаточно часто решаются задачи, в которых для описания условий используется граф. Однако не сложно заметить, что если мы не можем решить задачу с помощью эвристик, то пространственное состояние имеет экспоненциальную сложность в зависимости от числовых шагов. Если задаться целью обойти пространство состояний целиком, потребуется экспоненциальное время. Поэтому, методом поиска в пространстве состояний можно только не слишком сложные задачи. 

Для представление графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

## Задание

8. Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие -- последними, а белые -- посередине. Решить задачу за наименьшее число ходов.

## Принцип решения

Основной принцип решения задачи состоит в следующем: идем по списку, перебирая по 2 шара из списка, проверяем лежат ли эти шары в правильной последовательности, если нет, то меняем их местами. Я использовала 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах search_dpth, search_bdth и search_id соответсвенно.

Рассмотрим часть, общую для всех трех алгоритмов. Предикат prolong нужен, чтобы продлить все пути в графе, предотвращая зацикливания. 
```prolog
prolong([X|T],[Y,X|T]):-
    move(X,Y),
    \+ member(Y,[X|T]).
```

Предикат move отражает переход между состояниями в графе. Во втором правиле проходим по списку, представляющему одно состояние, меняем элементы, стоящие не на своем месте, что позволяет получить другое состояние. Предикат between генерирует все целые числа от 0 до Len, т.е. генерируем все числа от 0 до длины списка, затем проверяем, правильно ли стоят элементы с меньшим порядковым индексом относительно элементов с большим порядковым индексом, и меняем эти элементы.
```prolog
move([H|_],Res):-
    move(H,Res).

move(st(L),st(ResL)):-
    length(L,Len),
    Len1 is Len - 1,
    between(0,Len1,A),
    B is A + 1,
    check_correct(L,A,B),
    swap_elem(L,A,B,X),

    ResL = X.
```

В предикате check_correct получаем N-ый и M-ый элементы списка. За чёрным шаром не может лежать белый.
```prolog
check_correct(L,N,M):-
    getNthElem(L,X,N),
    getNthElem(L,Y,M),
    (X == b, Y == w),
    !.
```

## Результаты

```prolog
?- search_dpth(st([b,b,w,b,w,w,w]),st([w,w,w,w,b,b,b])).
DFS START
st([b,b,w,b,w,w,w])
st([b,w,b,b,w,w,w])
st([w,b,b,b,w,w,w])
st([w,b,b,w,b,w,w])
st([w,b,w,b,b,w,w])
st([w,w,b,b,b,w,w])
st([w,w,b,b,w,b,w])
st([w,w,b,w,b,b,w])
st([w,w,w,b,b,b,w])
st([w,w,w,b,b,w,b])
st([w,w,w,b,w,b,b])
st([w,w,w,w,b,b,b])
DFS END
TIME IS 0.0009138584136962891
true .
?- search_bdth(st([b,b,w,b,w,w,w]),st([w,w,w,w,b,b,b])).
BFS START
st([b,b,w,b,w,w,w])
st([b,w,b,b,w,w,w])
st([w,b,b,b,w,w,w])
st([w,b,b,w,b,w,w])
st([w,b,w,b,b,w,w])
st([w,w,b,b,b,w,w])
st([w,w,b,b,w,b,w])
st([w,w,b,w,b,b,w])
st([w,w,w,b,b,b,w])
st([w,w,w,b,b,w,b])
st([w,w,w,b,w,b,b])
st([w,w,w,w,b,b,b])
BFS END
TIME IS 0.3217463493347168
true .
?- search_id(st([b,b,w,b,w,w,w]),st([w,w,w,w,b,b,b])).
ITER START
st([b,b,w,b,w,w,w])
st([b,w,b,b,w,w,w])
st([w,b,b,b,w,w,w])
st([w,b,b,w,b,w,w])
st([w,b,w,b,b,w,w])
st([w,w,b,b,b,w,w])
st([w,w,b,b,w,b,w])
st([w,w,b,w,b,b,w])
st([w,w,w,b,b,b,w])
st([w,w,w,b,b,w,b])
st([w,w,w,b,w,b,b])
st([w,w,w,w,b,b,b])
ITER END
TIME IS 0.1724257469177246
true .

```

## Выводы

Все три алгоритма справились со своей задачей, но наиболее эффективно, как видно по результатам времени, оказался поиск в глубину. В этом нет ничего удивительного: в моем варианте существует лишь один способ решить задачу за наименьшее число ходов, и потому решение находится почти сразу.

Несложно заметить, что такой поиск в ширину имеет экспоненциальную сложность как по времени, так и по памяти. А поиск в глубину имеет экспоненциальную сложность по времени. Конечно, нам может повезти, и решение найдется сразу, но на практике это маловероятно. Поиск с итеративным углублением — это оптимизация поиска в глубину и в ширину, которая гарантированно позволяет найти самое близкое к начальному состоянию решение, избегая экспоненциальной сложности. Каким образом реализуется этот алгоритм? Мы ищем в глубину с ограничением глубины константой N. Нашли решение – хорошо. Не нашли — повторяем поиск в глубину с константой N+1 и так далее, пока не отыщется.

Для различных задач подходят различные виды поиска, и выбор должен зависеть от цели. В условиях ограничения по памяти лучше использовать поиск в глубину, а с целью поиска кратчайшего пути -- поиск в ширину. Поиск с итеративным углублением хоть и избегает экспоненциальной сложности, но пригоден только для самых простых задач. Конечно, лучше всего использовать эвристический поиск, что чаще и делают на практике. В отличие от использованных мной алгоритмов, эвристический поиск ищет в пространстве состояний более целенаправленно, т.к. имеет функцию оценки состояния. Вообще стратегии использования пространства состояний очень удобны, мне не нужно было для каждого поиска формулировать задачу заново или вносить в формулировку изменения.

