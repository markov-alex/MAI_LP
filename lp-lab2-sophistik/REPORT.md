#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Иванопуло А.Б. ???

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует 2 основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. Они оба перебирают некоторый набор решений. Суть первого метода состоит в том, что некоторый предикат генерирует множество исходных данных, которые затем проверяются другими предикатами на предмет соответствия условию задачи. В случае неуспеха происходит возврат и рассмотрение следующего решения, в случае успеха полученное решение возвращается пользователю или используется дальше. Второй метод можно противопоставить первому. В методе ветвей и границ значительные части возможных решений отсекаются на раннем этапе выполнения или вообще не генерируются. Например, можно использовать предикат member одновременно для генерации и для проверки, таким образом генерируются не все варианты решений, а какое-то их подмножество. Очевидно, что программа, написанная с помощью второго метода, будет работать быстрее.

Пролог удобен для решения логических задач, потому что он дает возможность рассмотрения большого количества вариантов решения задачи и выбора из них подходящих. При обнаружении неуспеха Пролог автоматически пересматривает решение и вытается продолжить выполнение программы при других значениях переменных.

## Задание
Вариант 14.

В педагогическом институте Аркадьева, Бабанова, Корсакова, Дашков, Ильин и Флеров преподают географию, английский язык, французский язык, немецкий язык, историю и математику. Преподаватель немецкого языка и преподаватель математики в студенческие годы занимались художественной гимнастикой. Ильин старше Флерова, но стаж работы у него меньше, чем у преподавателя географии. Будучи студентками, Аркадьева и Бабанова учились вместе в одном университете. Все остальные окончили педагогический институт. Флеров отец преподавателя французского языка. Преподаватель английского языка самый старший из всех и по возрасту и по стажу. Он работает в этом институте с тех пор, как окончил его. Преподаватели математики и истории его бывшие студенты. Аркадьева старше преподавателя немецкого языка. Кто какой предмет преподает?

## Принцип решения

Главный предикат main. Есть список преподавателей -- Аркадьева (Arkadieva), Бабанова (Babanova), Корсакова (Korsakova), Дашков (Dashkov), Ильин (Ilin) и Флеров (Flerov). Каждому преподавателю ставим в соответствие предикат teach, который проверяет, являются ли аргументы учебными предметами. Каждый преподаватель характеризуется 1 предметом, который он ведет. Предметы перебираем по очереди, причем если это один и тот же предмет, то такой вариант не проверяем (в коде это Sub2 @< Sub1 и проч). Когда список сформирован, проверяем условия задачи для данного списка.

Условие "в студенческие годы занимались художественной гимнастикой" отражен в предикате gymnastics
` gymnastics(T). `

С помощью предикатов is_older и work_longer мы задаем, старше ли первый преподаватель и работает ли он дольше соответственно.
```
is_older(T1, T2).
work_longer(T1, T2).
```
Предикат is_father означает, что первый преподаватель является отцом второго преподавателя.

`is_father(T1, T2).`

По условию, самый старший препователь является таковым и по возрасту и по стажу. Значит, он старше и работает дольше всех. Это и было отражено в предикате is_oldest.
```
is_oldest(T):-
    is_older(T, _),
    work_longer(T, _).
```
Последний предикат is_teacher отражает то, что первый преподаватель учил второго.
`is_teacher(T1, T2).`

Результат работы:

```
?- main([teach(Arkadieva_sub), teach(Babanova_sub), teach(Korsakova_sub), teach(Dashkov_sub), teach(Ilin_sub), teach(Flerov_sub)]).

Arkadieva_sub = math
Babanova_sub = history
Dashkov_sub = geography
Flerov_sub = english
Ilin_sub = french
Korsakova_sub = german
```

## Выводы

Пролог, безусловно, удобен для решения подобных задач. Описав ряд условий, мы отсекаем неподходящие варианты и находим нужное решение. Это намного проще, чем решать вручную, если бы мы, подобно программе, проверяли все возможные решения. Однако, если такая задача одна и там немного входных данных, то проще решить ее на бумаге. На больших данных я все-таки легче написать программу, но представить себе ситуацию, при которой пришлось бы решать большое количество таких задач, очень сложно. Также стоит отметить такой недостаток, что похожие по смыслу задачи решаются на Прологе механически -- мы просто меняем предикаты с условиями и генерацию. Думаю, если бы мы формализовали условие и написали все возможные проверки вообще (написание которых наверняка тоже можно как-то автоматизировать), то смогли бы решать целые классы таких задач.

Оценка сложности, непротиворечивости, эффективности
